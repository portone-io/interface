// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: escrow/escrow.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_escrow_2fescrow_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_escrow_2fescrow_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_escrow_2fescrow_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_escrow_2fescrow_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_escrow_2fescrow_2eproto;
namespace escrow {
class EscrowRequest;
class EscrowRequestDefaultTypeInternal;
extern EscrowRequestDefaultTypeInternal _EscrowRequest_default_instance_;
class EscrowResponse;
class EscrowResponseDefaultTypeInternal;
extern EscrowResponseDefaultTypeInternal _EscrowResponse_default_instance_;
class Info;
class InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class Logis;
class LogisDefaultTypeInternal;
extern LogisDefaultTypeInternal _Logis_default_instance_;
}  // namespace escrow
PROTOBUF_NAMESPACE_OPEN
template<> ::escrow::EscrowRequest* Arena::CreateMaybeMessage<::escrow::EscrowRequest>(Arena*);
template<> ::escrow::EscrowResponse* Arena::CreateMaybeMessage<::escrow::EscrowResponse>(Arena*);
template<> ::escrow::Info* Arena::CreateMaybeMessage<::escrow::Info>(Arena*);
template<> ::escrow::Logis* Arena::CreateMaybeMessage<::escrow::Logis>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace escrow {

// ===================================================================

class Info PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:escrow.Info) */ {
 public:
  inline Info() : Info(nullptr) {}
  virtual ~Info();

  Info(const Info& from);
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Info& operator=(Info&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Info* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Info* New() const final {
    return CreateMaybeMessage<Info>(nullptr);
  }

  Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Info& from);
  void MergeFrom(const Info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "escrow.Info";
  }
  protected:
  explicit Info(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_escrow_2fescrow_2eproto);
    return ::descriptor_table_escrow_2fescrow_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTelFieldNumber = 2,
    kAddrFieldNumber = 3,
    kPostcodeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string tel = 2;
  void clear_tel();
  const std::string& tel() const;
  void set_tel(const std::string& value);
  void set_tel(std::string&& value);
  void set_tel(const char* value);
  void set_tel(const char* value, size_t size);
  std::string* mutable_tel();
  std::string* release_tel();
  void set_allocated_tel(std::string* tel);
  private:
  const std::string& _internal_tel() const;
  void _internal_set_tel(const std::string& value);
  std::string* _internal_mutable_tel();
  public:

  // string addr = 3;
  void clear_addr();
  const std::string& addr() const;
  void set_addr(const std::string& value);
  void set_addr(std::string&& value);
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  std::string* mutable_addr();
  std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string postcode = 4;
  void clear_postcode();
  const std::string& postcode() const;
  void set_postcode(const std::string& value);
  void set_postcode(std::string&& value);
  void set_postcode(const char* value);
  void set_postcode(const char* value, size_t size);
  std::string* mutable_postcode();
  std::string* release_postcode();
  void set_allocated_postcode(std::string* postcode);
  private:
  const std::string& _internal_postcode() const;
  void _internal_set_postcode(const std::string& value);
  std::string* _internal_mutable_postcode();
  public:

  // @@protoc_insertion_point(class_scope:escrow.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr postcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_escrow_2fescrow_2eproto;
};
// -------------------------------------------------------------------

class Logis PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:escrow.Logis) */ {
 public:
  inline Logis() : Logis(nullptr) {}
  virtual ~Logis();

  Logis(const Logis& from);
  Logis(Logis&& from) noexcept
    : Logis() {
    *this = ::std::move(from);
  }

  inline Logis& operator=(const Logis& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logis& operator=(Logis&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Logis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logis* internal_default_instance() {
    return reinterpret_cast<const Logis*>(
               &_Logis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Logis& a, Logis& b) {
    a.Swap(&b);
  }
  inline void Swap(Logis* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logis* New() const final {
    return CreateMaybeMessage<Logis>(nullptr);
  }

  Logis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logis>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logis& from);
  void MergeFrom(const Logis& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logis* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "escrow.Logis";
  }
  protected:
  explicit Logis(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_escrow_2fescrow_2eproto);
    return ::descriptor_table_escrow_2fescrow_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompanyFieldNumber = 1,
    kInvoiceFieldNumber = 2,
    kSentAtFieldNumber = 3,
    kAppliedAtFieldNumber = 4,
  };
  // string company = 1;
  void clear_company();
  const std::string& company() const;
  void set_company(const std::string& value);
  void set_company(std::string&& value);
  void set_company(const char* value);
  void set_company(const char* value, size_t size);
  std::string* mutable_company();
  std::string* release_company();
  void set_allocated_company(std::string* company);
  private:
  const std::string& _internal_company() const;
  void _internal_set_company(const std::string& value);
  std::string* _internal_mutable_company();
  public:

  // string invoice = 2;
  void clear_invoice();
  const std::string& invoice() const;
  void set_invoice(const std::string& value);
  void set_invoice(std::string&& value);
  void set_invoice(const char* value);
  void set_invoice(const char* value, size_t size);
  std::string* mutable_invoice();
  std::string* release_invoice();
  void set_allocated_invoice(std::string* invoice);
  private:
  const std::string& _internal_invoice() const;
  void _internal_set_invoice(const std::string& value);
  std::string* _internal_mutable_invoice();
  public:

  // int32 sent_at = 3;
  void clear_sent_at();
  ::PROTOBUF_NAMESPACE_ID::int32 sent_at() const;
  void set_sent_at(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sent_at() const;
  void _internal_set_sent_at(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 applied_at = 4;
  void clear_applied_at();
  ::PROTOBUF_NAMESPACE_ID::int32 applied_at() const;
  void set_applied_at(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_applied_at() const;
  void _internal_set_applied_at(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:escrow.Logis)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr company_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_;
  ::PROTOBUF_NAMESPACE_ID::int32 sent_at_;
  ::PROTOBUF_NAMESPACE_ID::int32 applied_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_escrow_2fescrow_2eproto;
};
// -------------------------------------------------------------------

class EscrowRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:escrow.EscrowRequest) */ {
 public:
  inline EscrowRequest() : EscrowRequest(nullptr) {}
  virtual ~EscrowRequest();

  EscrowRequest(const EscrowRequest& from);
  EscrowRequest(EscrowRequest&& from) noexcept
    : EscrowRequest() {
    *this = ::std::move(from);
  }

  inline EscrowRequest& operator=(const EscrowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EscrowRequest& operator=(EscrowRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EscrowRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EscrowRequest* internal_default_instance() {
    return reinterpret_cast<const EscrowRequest*>(
               &_EscrowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EscrowRequest& a, EscrowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EscrowRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EscrowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EscrowRequest* New() const final {
    return CreateMaybeMessage<EscrowRequest>(nullptr);
  }

  EscrowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EscrowRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EscrowRequest& from);
  void MergeFrom(const EscrowRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EscrowRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "escrow.EscrowRequest";
  }
  protected:
  explicit EscrowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_escrow_2fescrow_2eproto);
    return ::descriptor_table_escrow_2fescrow_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
    kLogisFieldNumber = 3,
  };
  // .escrow.Info sender = 1;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::escrow::Info& sender() const;
  ::escrow::Info* release_sender();
  ::escrow::Info* mutable_sender();
  void set_allocated_sender(::escrow::Info* sender);
  private:
  const ::escrow::Info& _internal_sender() const;
  ::escrow::Info* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::escrow::Info* sender);
  ::escrow::Info* unsafe_arena_release_sender();

  // .escrow.Info receiver = 2;
  bool has_receiver() const;
  private:
  bool _internal_has_receiver() const;
  public:
  void clear_receiver();
  const ::escrow::Info& receiver() const;
  ::escrow::Info* release_receiver();
  ::escrow::Info* mutable_receiver();
  void set_allocated_receiver(::escrow::Info* receiver);
  private:
  const ::escrow::Info& _internal_receiver() const;
  ::escrow::Info* _internal_mutable_receiver();
  public:
  void unsafe_arena_set_allocated_receiver(
      ::escrow::Info* receiver);
  ::escrow::Info* unsafe_arena_release_receiver();

  // .escrow.Logis logis = 3;
  bool has_logis() const;
  private:
  bool _internal_has_logis() const;
  public:
  void clear_logis();
  const ::escrow::Logis& logis() const;
  ::escrow::Logis* release_logis();
  ::escrow::Logis* mutable_logis();
  void set_allocated_logis(::escrow::Logis* logis);
  private:
  const ::escrow::Logis& _internal_logis() const;
  ::escrow::Logis* _internal_mutable_logis();
  public:
  void unsafe_arena_set_allocated_logis(
      ::escrow::Logis* logis);
  ::escrow::Logis* unsafe_arena_release_logis();

  // @@protoc_insertion_point(class_scope:escrow.EscrowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::escrow::Info* sender_;
  ::escrow::Info* receiver_;
  ::escrow::Logis* logis_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_escrow_2fescrow_2eproto;
};
// -------------------------------------------------------------------

class EscrowResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:escrow.EscrowResponse) */ {
 public:
  inline EscrowResponse() : EscrowResponse(nullptr) {}
  virtual ~EscrowResponse();

  EscrowResponse(const EscrowResponse& from);
  EscrowResponse(EscrowResponse&& from) noexcept
    : EscrowResponse() {
    *this = ::std::move(from);
  }

  inline EscrowResponse& operator=(const EscrowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EscrowResponse& operator=(EscrowResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EscrowResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EscrowResponse* internal_default_instance() {
    return reinterpret_cast<const EscrowResponse*>(
               &_EscrowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EscrowResponse& a, EscrowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EscrowResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EscrowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EscrowResponse* New() const final {
    return CreateMaybeMessage<EscrowResponse>(nullptr);
  }

  EscrowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EscrowResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EscrowResponse& from);
  void MergeFrom(const EscrowResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EscrowResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "escrow.EscrowResponse";
  }
  protected:
  explicit EscrowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_escrow_2fescrow_2eproto);
    return ::descriptor_table_escrow_2fescrow_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kResponseFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .escrow.Logis response = 3;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::escrow::Logis& response() const;
  ::escrow::Logis* release_response();
  ::escrow::Logis* mutable_response();
  void set_allocated_response(::escrow::Logis* response);
  private:
  const ::escrow::Logis& _internal_response() const;
  ::escrow::Logis* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::escrow::Logis* response);
  ::escrow::Logis* unsafe_arena_release_response();

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:escrow.EscrowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::escrow::Logis* response_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_escrow_2fescrow_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Info

// string name = 1;
inline void Info::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Info::name() const {
  // @@protoc_insertion_point(field_get:escrow.Info.name)
  return _internal_name();
}
inline void Info::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:escrow.Info.name)
}
inline std::string* Info::mutable_name() {
  // @@protoc_insertion_point(field_mutable:escrow.Info.name)
  return _internal_mutable_name();
}
inline const std::string& Info::_internal_name() const {
  return name_.Get();
}
inline void Info::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Info::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:escrow.Info.name)
}
inline void Info::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:escrow.Info.name)
}
inline void Info::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:escrow.Info.name)
}
inline std::string* Info::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Info::release_name() {
  // @@protoc_insertion_point(field_release:escrow.Info.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Info::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:escrow.Info.name)
}

// string tel = 2;
inline void Info::clear_tel() {
  tel_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Info::tel() const {
  // @@protoc_insertion_point(field_get:escrow.Info.tel)
  return _internal_tel();
}
inline void Info::set_tel(const std::string& value) {
  _internal_set_tel(value);
  // @@protoc_insertion_point(field_set:escrow.Info.tel)
}
inline std::string* Info::mutable_tel() {
  // @@protoc_insertion_point(field_mutable:escrow.Info.tel)
  return _internal_mutable_tel();
}
inline const std::string& Info::_internal_tel() const {
  return tel_.Get();
}
inline void Info::_internal_set_tel(const std::string& value) {
  
  tel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Info::set_tel(std::string&& value) {
  
  tel_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:escrow.Info.tel)
}
inline void Info::set_tel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:escrow.Info.tel)
}
inline void Info::set_tel(const char* value,
    size_t size) {
  
  tel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:escrow.Info.tel)
}
inline std::string* Info::_internal_mutable_tel() {
  
  return tel_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Info::release_tel() {
  // @@protoc_insertion_point(field_release:escrow.Info.tel)
  return tel_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Info::set_allocated_tel(std::string* tel) {
  if (tel != nullptr) {
    
  } else {
    
  }
  tel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tel,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:escrow.Info.tel)
}

// string addr = 3;
inline void Info::clear_addr() {
  addr_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Info::addr() const {
  // @@protoc_insertion_point(field_get:escrow.Info.addr)
  return _internal_addr();
}
inline void Info::set_addr(const std::string& value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:escrow.Info.addr)
}
inline std::string* Info::mutable_addr() {
  // @@protoc_insertion_point(field_mutable:escrow.Info.addr)
  return _internal_mutable_addr();
}
inline const std::string& Info::_internal_addr() const {
  return addr_.Get();
}
inline void Info::_internal_set_addr(const std::string& value) {
  
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Info::set_addr(std::string&& value) {
  
  addr_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:escrow.Info.addr)
}
inline void Info::set_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:escrow.Info.addr)
}
inline void Info::set_addr(const char* value,
    size_t size) {
  
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:escrow.Info.addr)
}
inline std::string* Info::_internal_mutable_addr() {
  
  return addr_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Info::release_addr() {
  // @@protoc_insertion_point(field_release:escrow.Info.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Info::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:escrow.Info.addr)
}

// string postcode = 4;
inline void Info::clear_postcode() {
  postcode_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Info::postcode() const {
  // @@protoc_insertion_point(field_get:escrow.Info.postcode)
  return _internal_postcode();
}
inline void Info::set_postcode(const std::string& value) {
  _internal_set_postcode(value);
  // @@protoc_insertion_point(field_set:escrow.Info.postcode)
}
inline std::string* Info::mutable_postcode() {
  // @@protoc_insertion_point(field_mutable:escrow.Info.postcode)
  return _internal_mutable_postcode();
}
inline const std::string& Info::_internal_postcode() const {
  return postcode_.Get();
}
inline void Info::_internal_set_postcode(const std::string& value) {
  
  postcode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Info::set_postcode(std::string&& value) {
  
  postcode_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:escrow.Info.postcode)
}
inline void Info::set_postcode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  postcode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:escrow.Info.postcode)
}
inline void Info::set_postcode(const char* value,
    size_t size) {
  
  postcode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:escrow.Info.postcode)
}
inline std::string* Info::_internal_mutable_postcode() {
  
  return postcode_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Info::release_postcode() {
  // @@protoc_insertion_point(field_release:escrow.Info.postcode)
  return postcode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Info::set_allocated_postcode(std::string* postcode) {
  if (postcode != nullptr) {
    
  } else {
    
  }
  postcode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), postcode,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:escrow.Info.postcode)
}

// -------------------------------------------------------------------

// Logis

// string company = 1;
inline void Logis::clear_company() {
  company_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Logis::company() const {
  // @@protoc_insertion_point(field_get:escrow.Logis.company)
  return _internal_company();
}
inline void Logis::set_company(const std::string& value) {
  _internal_set_company(value);
  // @@protoc_insertion_point(field_set:escrow.Logis.company)
}
inline std::string* Logis::mutable_company() {
  // @@protoc_insertion_point(field_mutable:escrow.Logis.company)
  return _internal_mutable_company();
}
inline const std::string& Logis::_internal_company() const {
  return company_.Get();
}
inline void Logis::_internal_set_company(const std::string& value) {
  
  company_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Logis::set_company(std::string&& value) {
  
  company_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:escrow.Logis.company)
}
inline void Logis::set_company(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  company_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:escrow.Logis.company)
}
inline void Logis::set_company(const char* value,
    size_t size) {
  
  company_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:escrow.Logis.company)
}
inline std::string* Logis::_internal_mutable_company() {
  
  return company_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Logis::release_company() {
  // @@protoc_insertion_point(field_release:escrow.Logis.company)
  return company_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Logis::set_allocated_company(std::string* company) {
  if (company != nullptr) {
    
  } else {
    
  }
  company_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), company,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:escrow.Logis.company)
}

// string invoice = 2;
inline void Logis::clear_invoice() {
  invoice_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Logis::invoice() const {
  // @@protoc_insertion_point(field_get:escrow.Logis.invoice)
  return _internal_invoice();
}
inline void Logis::set_invoice(const std::string& value) {
  _internal_set_invoice(value);
  // @@protoc_insertion_point(field_set:escrow.Logis.invoice)
}
inline std::string* Logis::mutable_invoice() {
  // @@protoc_insertion_point(field_mutable:escrow.Logis.invoice)
  return _internal_mutable_invoice();
}
inline const std::string& Logis::_internal_invoice() const {
  return invoice_.Get();
}
inline void Logis::_internal_set_invoice(const std::string& value) {
  
  invoice_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Logis::set_invoice(std::string&& value) {
  
  invoice_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:escrow.Logis.invoice)
}
inline void Logis::set_invoice(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  invoice_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:escrow.Logis.invoice)
}
inline void Logis::set_invoice(const char* value,
    size_t size) {
  
  invoice_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:escrow.Logis.invoice)
}
inline std::string* Logis::_internal_mutable_invoice() {
  
  return invoice_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Logis::release_invoice() {
  // @@protoc_insertion_point(field_release:escrow.Logis.invoice)
  return invoice_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Logis::set_allocated_invoice(std::string* invoice) {
  if (invoice != nullptr) {
    
  } else {
    
  }
  invoice_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:escrow.Logis.invoice)
}

// int32 sent_at = 3;
inline void Logis::clear_sent_at() {
  sent_at_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logis::_internal_sent_at() const {
  return sent_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logis::sent_at() const {
  // @@protoc_insertion_point(field_get:escrow.Logis.sent_at)
  return _internal_sent_at();
}
inline void Logis::_internal_set_sent_at(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sent_at_ = value;
}
inline void Logis::set_sent_at(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sent_at(value);
  // @@protoc_insertion_point(field_set:escrow.Logis.sent_at)
}

// int32 applied_at = 4;
inline void Logis::clear_applied_at() {
  applied_at_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logis::_internal_applied_at() const {
  return applied_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logis::applied_at() const {
  // @@protoc_insertion_point(field_get:escrow.Logis.applied_at)
  return _internal_applied_at();
}
inline void Logis::_internal_set_applied_at(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  applied_at_ = value;
}
inline void Logis::set_applied_at(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_applied_at(value);
  // @@protoc_insertion_point(field_set:escrow.Logis.applied_at)
}

// -------------------------------------------------------------------

// EscrowRequest

// .escrow.Info sender = 1;
inline bool EscrowRequest::_internal_has_sender() const {
  return this != internal_default_instance() && sender_ != nullptr;
}
inline bool EscrowRequest::has_sender() const {
  return _internal_has_sender();
}
inline void EscrowRequest::clear_sender() {
  if (GetArena() == nullptr && sender_ != nullptr) {
    delete sender_;
  }
  sender_ = nullptr;
}
inline const ::escrow::Info& EscrowRequest::_internal_sender() const {
  const ::escrow::Info* p = sender_;
  return p != nullptr ? *p : *reinterpret_cast<const ::escrow::Info*>(
      &::escrow::_Info_default_instance_);
}
inline const ::escrow::Info& EscrowRequest::sender() const {
  // @@protoc_insertion_point(field_get:escrow.EscrowRequest.sender)
  return _internal_sender();
}
inline void EscrowRequest::unsafe_arena_set_allocated_sender(
    ::escrow::Info* sender) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_);
  }
  sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:escrow.EscrowRequest.sender)
}
inline ::escrow::Info* EscrowRequest::release_sender() {
  
  ::escrow::Info* temp = sender_;
  sender_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::escrow::Info* EscrowRequest::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:escrow.EscrowRequest.sender)
  
  ::escrow::Info* temp = sender_;
  sender_ = nullptr;
  return temp;
}
inline ::escrow::Info* EscrowRequest::_internal_mutable_sender() {
  
  if (sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::escrow::Info>(GetArena());
    sender_ = p;
  }
  return sender_;
}
inline ::escrow::Info* EscrowRequest::mutable_sender() {
  // @@protoc_insertion_point(field_mutable:escrow.EscrowRequest.sender)
  return _internal_mutable_sender();
}
inline void EscrowRequest::set_allocated_sender(::escrow::Info* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sender);
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:escrow.EscrowRequest.sender)
}

// .escrow.Info receiver = 2;
inline bool EscrowRequest::_internal_has_receiver() const {
  return this != internal_default_instance() && receiver_ != nullptr;
}
inline bool EscrowRequest::has_receiver() const {
  return _internal_has_receiver();
}
inline void EscrowRequest::clear_receiver() {
  if (GetArena() == nullptr && receiver_ != nullptr) {
    delete receiver_;
  }
  receiver_ = nullptr;
}
inline const ::escrow::Info& EscrowRequest::_internal_receiver() const {
  const ::escrow::Info* p = receiver_;
  return p != nullptr ? *p : *reinterpret_cast<const ::escrow::Info*>(
      &::escrow::_Info_default_instance_);
}
inline const ::escrow::Info& EscrowRequest::receiver() const {
  // @@protoc_insertion_point(field_get:escrow.EscrowRequest.receiver)
  return _internal_receiver();
}
inline void EscrowRequest::unsafe_arena_set_allocated_receiver(
    ::escrow::Info* receiver) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(receiver_);
  }
  receiver_ = receiver;
  if (receiver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:escrow.EscrowRequest.receiver)
}
inline ::escrow::Info* EscrowRequest::release_receiver() {
  
  ::escrow::Info* temp = receiver_;
  receiver_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::escrow::Info* EscrowRequest::unsafe_arena_release_receiver() {
  // @@protoc_insertion_point(field_release:escrow.EscrowRequest.receiver)
  
  ::escrow::Info* temp = receiver_;
  receiver_ = nullptr;
  return temp;
}
inline ::escrow::Info* EscrowRequest::_internal_mutable_receiver() {
  
  if (receiver_ == nullptr) {
    auto* p = CreateMaybeMessage<::escrow::Info>(GetArena());
    receiver_ = p;
  }
  return receiver_;
}
inline ::escrow::Info* EscrowRequest::mutable_receiver() {
  // @@protoc_insertion_point(field_mutable:escrow.EscrowRequest.receiver)
  return _internal_mutable_receiver();
}
inline void EscrowRequest::set_allocated_receiver(::escrow::Info* receiver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete receiver_;
  }
  if (receiver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(receiver);
    if (message_arena != submessage_arena) {
      receiver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver, submessage_arena);
    }
    
  } else {
    
  }
  receiver_ = receiver;
  // @@protoc_insertion_point(field_set_allocated:escrow.EscrowRequest.receiver)
}

// .escrow.Logis logis = 3;
inline bool EscrowRequest::_internal_has_logis() const {
  return this != internal_default_instance() && logis_ != nullptr;
}
inline bool EscrowRequest::has_logis() const {
  return _internal_has_logis();
}
inline void EscrowRequest::clear_logis() {
  if (GetArena() == nullptr && logis_ != nullptr) {
    delete logis_;
  }
  logis_ = nullptr;
}
inline const ::escrow::Logis& EscrowRequest::_internal_logis() const {
  const ::escrow::Logis* p = logis_;
  return p != nullptr ? *p : *reinterpret_cast<const ::escrow::Logis*>(
      &::escrow::_Logis_default_instance_);
}
inline const ::escrow::Logis& EscrowRequest::logis() const {
  // @@protoc_insertion_point(field_get:escrow.EscrowRequest.logis)
  return _internal_logis();
}
inline void EscrowRequest::unsafe_arena_set_allocated_logis(
    ::escrow::Logis* logis) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logis_);
  }
  logis_ = logis;
  if (logis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:escrow.EscrowRequest.logis)
}
inline ::escrow::Logis* EscrowRequest::release_logis() {
  
  ::escrow::Logis* temp = logis_;
  logis_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::escrow::Logis* EscrowRequest::unsafe_arena_release_logis() {
  // @@protoc_insertion_point(field_release:escrow.EscrowRequest.logis)
  
  ::escrow::Logis* temp = logis_;
  logis_ = nullptr;
  return temp;
}
inline ::escrow::Logis* EscrowRequest::_internal_mutable_logis() {
  
  if (logis_ == nullptr) {
    auto* p = CreateMaybeMessage<::escrow::Logis>(GetArena());
    logis_ = p;
  }
  return logis_;
}
inline ::escrow::Logis* EscrowRequest::mutable_logis() {
  // @@protoc_insertion_point(field_mutable:escrow.EscrowRequest.logis)
  return _internal_mutable_logis();
}
inline void EscrowRequest::set_allocated_logis(::escrow::Logis* logis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete logis_;
  }
  if (logis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(logis);
    if (message_arena != submessage_arena) {
      logis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logis, submessage_arena);
    }
    
  } else {
    
  }
  logis_ = logis;
  // @@protoc_insertion_point(field_set_allocated:escrow.EscrowRequest.logis)
}

// -------------------------------------------------------------------

// EscrowResponse

// int32 code = 1;
inline void EscrowResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EscrowResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EscrowResponse::code() const {
  // @@protoc_insertion_point(field_get:escrow.EscrowResponse.code)
  return _internal_code();
}
inline void EscrowResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void EscrowResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:escrow.EscrowResponse.code)
}

// string message = 2;
inline void EscrowResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EscrowResponse::message() const {
  // @@protoc_insertion_point(field_get:escrow.EscrowResponse.message)
  return _internal_message();
}
inline void EscrowResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:escrow.EscrowResponse.message)
}
inline std::string* EscrowResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:escrow.EscrowResponse.message)
  return _internal_mutable_message();
}
inline const std::string& EscrowResponse::_internal_message() const {
  return message_.Get();
}
inline void EscrowResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EscrowResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:escrow.EscrowResponse.message)
}
inline void EscrowResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:escrow.EscrowResponse.message)
}
inline void EscrowResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:escrow.EscrowResponse.message)
}
inline std::string* EscrowResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EscrowResponse::release_message() {
  // @@protoc_insertion_point(field_release:escrow.EscrowResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EscrowResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:escrow.EscrowResponse.message)
}

// .escrow.Logis response = 3;
inline bool EscrowResponse::_internal_has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline bool EscrowResponse::has_response() const {
  return _internal_has_response();
}
inline void EscrowResponse::clear_response() {
  if (GetArena() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::escrow::Logis& EscrowResponse::_internal_response() const {
  const ::escrow::Logis* p = response_;
  return p != nullptr ? *p : *reinterpret_cast<const ::escrow::Logis*>(
      &::escrow::_Logis_default_instance_);
}
inline const ::escrow::Logis& EscrowResponse::response() const {
  // @@protoc_insertion_point(field_get:escrow.EscrowResponse.response)
  return _internal_response();
}
inline void EscrowResponse::unsafe_arena_set_allocated_response(
    ::escrow::Logis* response) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:escrow.EscrowResponse.response)
}
inline ::escrow::Logis* EscrowResponse::release_response() {
  
  ::escrow::Logis* temp = response_;
  response_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::escrow::Logis* EscrowResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:escrow.EscrowResponse.response)
  
  ::escrow::Logis* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::escrow::Logis* EscrowResponse::_internal_mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::escrow::Logis>(GetArena());
    response_ = p;
  }
  return response_;
}
inline ::escrow::Logis* EscrowResponse::mutable_response() {
  // @@protoc_insertion_point(field_mutable:escrow.EscrowResponse.response)
  return _internal_mutable_response();
}
inline void EscrowResponse::set_allocated_response(::escrow::Logis* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:escrow.EscrowResponse.response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace escrow

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_escrow_2fescrow_2eproto
